"""Animate the pendulum simulation data generated by pendulum.cpp"""

from __future__ import annotations
import struct
import tkinter as tk
from typing import List

SCALE = 50

class Colors:
    NODE = "#03396c"
    LINK = "#6497b1"

class Pin:
    fmt = "dd"
    unpack = struct.Struct(fmt).unpack_from
    structsize = struct.calcsize(fmt)
    def __init__(self, x: float, y: float):
        self.x = x
        self.y = y

    def __str__(self):
        return f"Pin({self.x}, {self.y})"


class Point:
    def __init__(self, x: float, y: float):
        self.x = x
        self.y = y

    @staticmethod
    def FromPin(pin: Pin) -> Point:
        return Point(pin.x, pin.y)

    @staticmethod
    def FromNode(node: Node) -> Point:
        return Point(node.state.x, node.state.y)


class State:
    def __init__(self, x: float, y: float, xdot: float, ydot: float):
        self.x = x
        self.y = y
        self.xdot = xdot
        self.ydot = ydot

    def __str__(self):
        return f"State({self.x}, {self.y}, {self.xdot}, {self.ydot})"


class Node:
    fmt = "dddddddd"
    unpack = struct.Struct(fmt).unpack_from
    structsize = struct.calcsize(fmt)
    def __init__(self, m: float, l: float, k: float, c: float, x: float, y: float, xdot: float, ydot: float):
        self.m = m
        self.l = l
        self.k = k
        self.c = c
        self.state = State(x, y, xdot, ydot)

    def __str__(self):
        return f"Node({self.m}, {self.l}, {self.k}, {self.c}, {self.state})"

    def __repr__(self):
        return self.__str__()


class Chain:
    def __init__(self, ts: float, pin: Pin, nodes: List[Node]):
        self.ts = ts
        self.pin = pin
        self.nodes = nodes

    def __str__(self):
        return f"t: {self.ts}, pin: {self.pin}, nodes: {self.nodes}"


def ReadChains(fp: str):
    """Generator for reading chains from the binary data file"""
    with open(fp, "rb") as f:
        while True:

            # Timestamp (double)
            tsData = f.read(struct.calcsize("d"))
            if not tsData: break # Signifies EOF
            ts, = struct.Struct("d").unpack_from(tsData)

            # Pin
            pinData = f.read(Pin.structsize)
            pin = Pin(*Pin.unpack(pinData))

            # Nodes (numNodes is size_t, i.e. unsigned long)
            numNodes, = struct.Struct("L").unpack_from(f.read(struct.calcsize("L")))

            nodes: List[Node] = []
            for _ in range(numNodes):
                nodeData = f.read(Node.structsize)
                node = Node(*Node.unpack(nodeData))
                nodes.append(node)

            yield Chain(ts, pin, nodes)


def CircleCoords(x, y, r):
    return x-r, y-r, x+r, y+r


class UiNode:
    def __init__(self, canvas: tk.Canvas, node: Node, pointPrevious: Point):
        self.canvas = canvas
        self.radius = 0.2
        x, y, x1, y1 = CircleCoords(node.state.x, node.state.y, self.radius)
        w = self._WidthAdjustment()
        h = self._HeightAdjustment()
        self.nodeId = canvas.create_oval(x + w, y + h, x1 + w, y1 + h, tags="node", outline="", fill=Colors.NODE)
        self.linkId = canvas.create_line(pointPrevious.x + w, pointPrevious.y + h, node.state.x + w, node.state.y + h, tags="link", fill=Colors.LINK, width=5)

    def _WidthAdjustment(self):
        """Add this to an x coordinate to center it"""
        return self.canvas.winfo_width() / 2 / SCALE

    def _HeightAdjustment(self):
        """Add this to an y coordinate for padding"""
        return self.canvas.winfo_height() * 0.05 / SCALE

    def Update(self, node: Node, pointPrevious: Point):
        x, y, x1, y1 = CircleCoords(node.state.x, node.state.y, self.radius)
        w = self._WidthAdjustment()
        h = self._HeightAdjustment()
        self.canvas.coords(self.nodeId, x + w, y + h, x1 + w, y1 + h)
        self.canvas.coords(self.linkId, pointPrevious.x + w, pointPrevious.y + h, node.state.x + w, node.state.y + h)


class App:
    def __init__(self, master, chainGenerator):
        self.master: tk.Tk = master
        self.master.bind_all('<Key>', self.HandleKeyPress)

        self.canvas: tk.Canvas = tk.Canvas(self.master, width=SCALE, height=SCALE)
        self.canvas.pack(fill="both", expand=True)
        self.scale = SCALE

        self.chain: Chain = None
        self.chainGenerator = chainGenerator
        self.timeDelta = 0
        self.renderTimeDelta = 20 # milliseconds
        self.InitializeChain()

    def HandleKeyPress(self, event):
        if event.char == 'q':
            self.master.quit()

    def InitializeChain(self):
        self.chain = next(self.chainGenerator)
        self.ts = self.chain.ts
        self.uiNodes: List[UiNode] = []
        for n, node in enumerate(self.chain.nodes):
            pointPrev = Point.FromPin(self.chain.pin) if n == 0 else Point.FromNode(self.chain.nodes[n-1])
            self.uiNodes.append(UiNode(self.canvas, node, pointPrev))
        self.canvas.scale("all", 0, 0, self.scale, self.scale)
        self.canvas.tag_raise("node", "link")
        self.master.after(0, self.Update)

    def NextRelevantChain(self):
        oldTime = self.chain.ts
        while self.chain.ts - oldTime < self.renderTimeDelta / 1000:
            try:
                self.chain = next(self.chainGenerator)
            except StopIteration:
                return None
        return self.chain

    def Update(self):
        self.canvas.update_idletasks()
        for n, node in enumerate(self.chain.nodes):
            pointPrev = Point.FromPin(self.chain.pin) if n == 0 else Point.FromNode(self.chain.nodes[n-1])
            self.uiNodes[n].Update(node, pointPrev)
        self.canvas.scale("all", 0, 0, self.scale, self.scale)

        self.chain = self.NextRelevantChain()
        if self.chain is None:
            self.master.destroy()
        else:
            self.master.after(self.renderTimeDelta, self.Update)


if __name__ == "__main__":
    import sys
    if len(sys.argv) != 2:
        print("pendulumplot.py")
        print("Usage: pendulumplot <datafile>")
        print("Where <datafile> is the resultant output from pendulum.cpp")
        sys.exit(1)

    # Assume data file is argument
    fp = sys.argv[1]
    chainGenerator = ReadChains(fp)

    # Initialize tk environment
    root = tk.Tk()
    app = App(root, chainGenerator)
    root.mainloop()
